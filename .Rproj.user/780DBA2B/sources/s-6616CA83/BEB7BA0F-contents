plot_map <- function(mesh,field,plot=TRUE,bigwidth = 3*361,bigheight =  3*181, leg_title ="") {

    lonlatpts <- lonlatfr3D(mesh$loc[,1],mesh$loc[,2],mesh$loc[,3])
    proj = inla.mesh.projector(mesh, dims=c(bigwidth,bigheight))
    lon_lat_grid <- expand.grid(lon = seq(-180,180,length = bigwidth),
                                lat = seq(-90,90,length = bigheight))
    zproj <- inla.mesh.project(proj, field=field)
    grid_data <- reshape2::melt(zproj)
    names(grid_data) <- c("lon","lat","z")
    grid_data[,1:2] <- lon_lat_grid

    XX <- filter(grid_data,!is.na(z))
    minx <- min(XX[,1])
    maxx <- max(XX[,1])
    miny <- min(XX[,2])
    maxy <- max(XX[,2])


    if(plot) {
        mapWorld <- borders("world", colour="black", fill="light gray")
        return(ggplot(grid_data) +
        geom_raster(aes(lon,lat,fill=z)) +
        scale_fill_distiller(palette="Spectral",name=leg_title,na.value="light gray") +
        coord_fixed(xlim=c(minx,maxx), ylim=c(miny,maxy),ratio=1.2) + mapWorld + theme_bw())
    } else {
        return(list(grid_data = grid_data,proj = proj))
    }
}


plot_3d_mesh <- function(mesh,new_window=TRUE,col="white",vertex.color="red",size=2) {
    if(new_window) {
        require(rgl)
        windowRect.globe = c(50,50,50+840,50+400)
        open3d(windowRect=windowRect.globe)
    }
    plot(mesh, rgl=TRUE, col=col,
         draw.vertices=TRUE, draw.edges=TRUE, add=TRUE,
         vertex.color=vertex.color,size=size)
}


lonlat3D=function(lon,lat){
    cbind(cos((lon/180)*pi)*cos((lat/180)*pi),
          sin((lon/180)*pi)*cos((lat/180)*pi),
          sin((lat/180)*pi))
}

lonlatfr3D <- function(x,y,z) {
    # lat = asin(z)*360/(2*pi)
    # lon = atan2(y, z)*360/(2*pi)
    lat = acos(z)*360/(2*pi)
    lon = atan2(y,x)*360/(2*pi)+180
    cbind(lon,(90-lat))
}

neighb_from_prec2 <- function(Q) {
    Q <- as(Q,"dgTMatrix")
    df <- data.frame(i=Q@i+1,j=Q@j+1) %>% group_by(i) %>% dplyr::summarise(j=list(j))
    i_full <- data.frame(i=1:nrow(Q))
    left_join(i_full,df)$j
}

MH <- function(theta,logf,eps=0.1,N=1000,verbose=1) {
    eps <-  0.1
    theta <- theta
    n <- length(theta)
    count <- 0
    acc_tot <- 0
    theta_accept_last10 <- rep(0,10)
    function(...) {
        count <<- count + 1
        if(count > 10) if(count < 100 | (count < 1000 & (count %% 10 == 0))) {
            if (sum(theta_accept_last10) >= 9)
                eps <<- eps * 1.1
            if (sum(theta_accept_last10) == 0)
                eps <<- eps / 1.1
            print(paste0("eps is now ",eps))
        }
        theta_new <- theta + eps*rnorm(n)
        logf_old <- logf(theta,...)
        logf_new <- logf(theta_new,...)
        acc_prob <- min(exp(logf_new - logf_old),1)
        U <- runif(1)
        theta_accept_last10[1:9] <<- theta_accept_last10[2:10]
        theta_accept_last10[10] <<- 0

        if(U < acc_prob) {
            acc_tot <<- acc_tot + 1
            theta <<- theta_new
            theta_accept_last10[10] <<- 1
            assign("current_hyp",get("new_hyp",environment(logf)),environment(logf))
            assign("current_Qx",get("new_Qx",environment(logf)),environment(logf))
            assign("current_logdet",get("new_logdet",environment(logf)),environment(logf))
        }
        if(verbose) print(paste0("Acceptance ratio = ",acc_tot/count))
        return(theta)
    }
}

log_f0_init <- function(name="kappatau") {
    if(name=="kappatau")  {
        new_hyp <- current_hyp <- c(Inf,Inf)
    } else {
        new_hyp <- current_hyp <- Inf
    }
    new_Qx <- current_Qx <- NULL
    new_logdet <- current_logdet <- NULL

    if(name=="kappatau") {
        function(hyp,spde,x0) {
            if(all(hyp == current_hyp)) {
                0.5*current_logdet -
                    0.5*t(x0) %*% current_Qx %*% x0
            } else {
                    new_hyp <<- hyp
                    new_Qx <<- inla.spde.precision(spde,
                                              theta=c(hyp[1], hyp[2]))
                    X <- cholPermute(new_Qx,method="amd")
                    new_logdet <<- MVST:::logdet(X$Qpermchol)
                    0.5*new_logdet -
                        0.5*t(x0) %*% new_Qx %*% x0
                }
        }
    } else if(name=="kappa") {
        function(hyp,spde,x0,log_tau) {
            if(hyp == current_hyp) {
                0.5*current_logdet -
                    0.5*t(x0) %*% current_Qx %*% x0
            } else {
                new_hyp <<- hyp
                new_Qx <<- inla.spde.precision(spde,
                                               theta=c(log_tau, hyp))
                X <- cholPermute(new_Qx,method="amd")
                new_logdet <<- MVST:::logdet(X$Qpermchol)
                0.5*new_logdet -
                    0.5*t(x0) %*% new_Qx %*% x0
            }
        }
    } else if(name=="tau") {
        function(hyp,spde,x0,log_kappa) {
            if(hyp == current_hyp) {
                0.5*current_logdet -
                    0.5*t(x0) %*% current_Qx %*% x0
            } else {
                new_hyp <<- hyp
                new_Qx <<- inla.spde.precision(spde,
                                               theta=c(hyp, log_kappa))
                X <- cholPermute(new_Qx,method="amd")
                new_logdet <<- MVST:::logdet(X$Qpermchol)
                0.5*new_logdet -
                    0.5*t(x0) %*% new_Qx %*% x0
            }
        }
    }
}


find_border_from_points <- function(pts) {
    if(diff(range(pts[,1])) > 180) {
        ind_left <- which(pts[,1] < 0)
        pts[ind_left,1] <- pts[ind_left,1] + 360
    }
    XX <- inla.nonconvex.hull(as.matrix(pts),convex=-0.06)
    D <- fields::rdist(XX$loc,pts)
    border_idx <- apply(D,1,which.min)
    pts[border_idx,]
}

logf_old <- function(theta,spde,Yx) {  ## Here theta = (log_tau,log_kappa)
    mu_ltau <- spde$param.inla$theta.mu[1]
    s2_ltau <- 1/spde$param.inla$theta.Q[1,1]

    mu_lkappa <- spde$param.inla$theta.mu[2]
    s2_lkappa <- 1/spde$param.inla$theta.Q[2,2]

    log_tau <- theta[1]
    log_kappa <- theta[2]

    if(theta[1] < (mu_ltau - 5*sqrt(s2_ltau)) |
       theta[1] > (mu_ltau + 5*sqrt(s2_ltau)) |
       theta[2] < (mu_lkappa - 5*sqrt(s2_lkappa)) |
       theta[2] > (mu_lkappa + 5*sqrt(s2_lkappa))) {
        -Inf
    } else {


        Qx = inla.spde.precision(spde, theta=c(log_tau, log_kappa))
        X <- cholPermute(Qx)
        logdet <<- MVST:::logdet(X$Qpermchol)

        as.numeric(
            0.5 * logdet - 0.5*t(Yx) %*% Qx %*% Yx -
                0.5*(log_tau - mu_ltau)^2/s2_ltau -
                0.5*(log_kappa - mu_lkappa)^2/s2_lkappa
        )
    }
}

logf <- function(theta,spde,Yx,Mall_df,QC,P) {  ## Here theta = (log_tau,log_kappa)
    mu_ltau <- spde$param.inla$theta.mu[1]
    s2_ltau <- 1/spde$param.inla$theta.Q[1,1]

    mu_lkappa <- spde$param.inla$theta.mu[2]
    s2_lkappa <- 1/spde$param.inla$theta.Q[2,2]

    log_tau <- theta[1]
    log_kappa <- theta[2]

    if(theta[1] < (mu_ltau - 5*sqrt(s2_ltau)) |
       theta[1] > (mu_ltau + 5*sqrt(s2_ltau)) |
       theta[2] < (mu_lkappa - 5*sqrt(s2_lkappa)) |
       theta[2] > (mu_lkappa + 5*sqrt(s2_lkappa))) {
        -Inf
    } else {
        Qx = inla.spde.precision.fast(spde, Mall_df = Mall_df,QC = QC,
                                      theta=c(log_tau, log_kappa))
        Qx_spam <- as.spam.dgCMatrix(Qx)
        L <- spam::chol(Qx_spam, pivot = P)
        logdet <- MVST:::logdet(L)

        as.numeric(
            0.5 * logdet - 0.5*t(Yx) %*% Qx %*% Yx -
                0.5*(log_tau - mu_ltau)^2/s2_ltau -
                0.5*(log_kappa - mu_lkappa)^2/s2_lkappa
        )
    }
}

## extract elements from spde M matrices into data frame. Note: M2 non zeroes are a superset of the M0 and M1 non zeroes
elements_in_df <- function(spde) {
    M0 <- spde$param.inla$M0
    M1 <- spde$param.inla$M1
    M2 <- spde$param.inla$M2

    M0_df <- data.frame(i = M0@i+1, j = M0@j + 1, x0 = M0@x)
    M1_df <- data.frame(i = M1@i+1, j = M1@j + 1, x1 = M1@x)
    M2_df <- data.frame(i = M2@i+1, j = M2@j + 1, x2 = M2@x)
    M_alldf <- left_join(left_join(M2_df,M1_df,by=c("i","j")),M0_df,by=c("i","j"))
    M_alldf$x0[which(is.na(M_alldf$x0))] <- 0
    M_alldf$x1[which(is.na(M_alldf$x1))] <- 0
    M_alldf
}

inla.spde.precision.fast <- function (spde, Mall_df,QC,theta = NULL,phi0 = inla.spde2.theta2phi0(spde,theta),
                   phi1 = inla.spde2.theta2phi1(spde, theta), phi2 = inla.spde2.theta2phi2(spde,theta))
{
    phi0 <- phi0[1]
    phi1 <- phi1[1]
    phi2 <- phi2[1]
    Q_elements <-  (phi0^2) * (phi1^2 * Mall_df$x0 + 2*phi1*phi2*Mall_df$x1 + Mall_df$x2)
    QC@x <- Q_elements

    return(as(QC,"dgCMatrix"))
}


coverage <- function(z,mu,se,average=TRUE,alpha=0.025) {
    if(alpha == 0.025) gamma = 1.96 else gamma = 1.64
    lower <- mu - gamma*se
    upper <- mu + gamma*se
    if(average)
        sum((z < upper) & (z > lower)) / length(z)
    else
        (z < upper) & (z > lower)
}

pred_results <- function(z,mu,se) {
    list(RMSPE = sqrt(mean((z-mu)^2)),
         Bias = mean(z-mu),
         coverage95 = coverage(z,mu,se,alpha=0.025),
         coverage90 = coverage(z,mu,se,alpha=0.05),
         crps = crps(z,cbind(mu,se))$CRPS)
}

## Generaetes an ocean mesh -- requires INLA
gen_ocean_mesh_hi_res <- function(coast_path,antarctica_path,
                           cutoff=100,max.edge=150) {

    true.radius.of.earth = 6371
    radius.of.earth = 1

    coastline <- readShapeSpatial(coast_path)
    antarctica <- readShapeSpatial(antarctica_path)
    poly_2_segments <- function(polys) {
        dfs <- lapply(polys@polygons,
                      function(l) l@Polygons[[1]]@coords)
        lapply(dfs,function(l) {
            coords3d <- lonlat3D(l[,1],l[,2])
            inla.mesh.segment(loc=coords3d)
        })
    }
    segm_coastlines <- poly_2_segments(coastline)
    segm_antarctica <- poly_2_segments(antarctica)

    inla.mesh.create(boundary=c(segm_coastlines[c(1:500)],
                                segm_antarctica),
                     cutoff=cutoff/true.radius.of.earth,
                     refine=list(max.edge=max.edge/true.radius.of.earth))
}


## Returns data frame
lo_res_mask <- function(aus_path,ant_path,eur_path) {

  aus <- read.table(aus_path)
  aus = rbind(aus,aus[1,])
  ant <- read.table(ant_path)
  ant <- rbind(ant,ant[1,])
  eur <-  read.table(eur_path)
  eur <- rbind(eur,eur[1,])
  colnames(aus) <- colnames(ant) <- colnames(eur) <- c("lon","lat")
  aus$id <- 1
  ant$id <- 2
  america <- eur[45:126,]
  eurasia <- eur[-c(45:126),]
  america$id <- 3
  eurasia$id <- 4
  df <-   rbind(aus,ant,america,eurasia)
  df$lon[df$lon > 180] <- df$lon[df$lon > 180] - 360
  df
}

gen_ocean_mesh_lo_res <- function(aus_path,ant_path,eur_path) {


    aus <- read.table(aus_path)
    aus = rbind(aus,aus[1,])
    ant <- read.table(ant_path)
    ant <- rbind(ant,ant[1,])
    eur <-  read.table(eur_path)
    eur <- rbind(eur,eur[1,])
    #Make everything 3D
    aus3 <- lonlat3D(aus[,1],aus[,2])
    ant3 <- lonlat3D(ant[,1],ant[,2])
    eur3 <- lonlat3D(eur[,1],eur[,2])
    segm_aus = inla.mesh.segment(loc=aus3)
    segm_ant = inla.mesh.segment(loc=ant3)
    segm_eur = inla.mesh.segment(loc=eur3)

    segm_world = list(segm_aus,segm_ant,segm_eur)
    mesh=inla.mesh.create(boundary=segm_world,
                          cutoff=cutoff/true.radius.of.earth,
                          refine=list(max.edge=max.edge/true.radius.of.earth,
                                      extend=list(offset=-0.5)))
}


INLA_spatial_estimation <- function(spde,z,C,C_pred) {
    s_index <- inla.spde.make.index(name = "spatial.field",
                                    n.spde = spde$n.spde)
    ## First stack: the model for estimation
    stack_est <- inla.stack(data = list(z = z),
                            A = list(C),
                            effects = list(c(s_index,list(Intercept=1))),
                            tag="est")
    ## Second stack: the model for prediction
    stack_pred <- inla.stack(data = list(z = NA),
                             A = list(C_pred),
                             effects = list(c(s_index,list(Intercept=1))),
                             tag="pred")
    ## Now combine
    stack <- inla.stack(stack_est,stack_pred)

    ## Formula
    formula <- z ~ -1 + Intercept +
        f(spatial.field,
          model=spde)

    output <- inla(formula,
                   data=inla.stack.data(stack,spde=spde),
                   family="gaussian",
                   control.predictor = list(A=inla.stack.A(stack),
                                            compute=FALSE),
                   control.results=list(return.marginals.random=FALSE,
                                        return.marginals.predictor=FALSE))
}


INLA_spatial_estimation2 <- function(spde,z,C) {
  s_index <- inla.spde.make.index(name = "spatial.field",
                                  n.spde = spde$n.spde)
  ## First stack: the model for estimation
  stack_est <- inla.stack(data = list(z = z),
                          A = list(C),
                          effects = list(c(s_index)),
                          tag="est")

  stack <- stack_est

  ## Formula
  formula <- z ~ -1 + f(spatial.field,model=spde)

  output <- inla(formula,
                 data=inla.stack.data(stack,spde=spde),
                 family="gaussian",
                 control.predictor = list(A=inla.stack.A(stack),
                                          compute=FALSE),
                 control.results=list(return.marginals.random=FALSE,
                                      return.marginals.predictor=FALSE))
}


plot_sub_obs <- function(i,y_tot,chunks) {
    ## What is Z? y_tot[obs_sub,]$z?
    obs_sub <-chunks[[i]]$obs_idx
    ggplot(y_tot[obs_sub,]) + geom_point(aes(lon,lat,
                                             #colour=as.numeric(Z[obs_sub] - C0[obs_sub,] %*% x_true0))) +
                                             #colour=as.numeric(Z[obs_sub] - C1_full[obs_sub,] %*% x_true1[[i]]))) +
                                             colour=as.numeric(Z[obs_sub]))) + spect
}


if(require(ggplot2)) {
  spect <- scale_colour_distiller(palette="Spectral",name="")
  nasa_palette <- c("#03006d","#02008f","#0000b6","#0001ef","#0000f6","#0428f6","#0b53f7","#0f81f3",
                  "#18b1f5","#1ff0f7","#27fada","#3efaa3","#5dfc7b","#85fd4e","#aefc2a","#e9fc0d","#f6da0c","#f5a009",
                  "#f6780a","#f34a09","#f2210a","#f50008","#d90009","#a80109","#730005")
  nasa_scale <- function(leg_title ="") scale_color_gradientn(colours=nasa_palette,name=leg_title)
}


get_slice_info <- function(sampler) {
  list(scale = get("scale",envir=environment(sampler)),
       updated = get("updated",envir=environment(sampler)),
       n = get("n",envir=environment(sampler)),
       m = get("m",envir=environment(sampler)),
       W = get("W",envir=environment(sampler)))
}

set_slice_info <- function(sampler,info) {
  assign("scale",info$scale,envir=environment(sampler))
  assign("updated",info$updated,envir=environment(sampler))
  assign("n",info$n,envir=environment(sampler))
  assign("m",info$m,envir=environment(sampler))
  assign("W",info$W,envir=environment(sampler))
  sampler
}


Findalphabeta_gamma <- function (pars, p5, p95)
{
    if (any(pars < 0)) {
        return(Inf)
    }
    else {
        return(sum((qgamma(c(0.05, 0.95), shape = pars[1], rate = pars[2]) -
            c(1/p95^2, 1/p5^2))^2/c(1/p95^2, 1/p5^2)))
    }
}
